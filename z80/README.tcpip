A tiny TCP/IP stack for Z80
===========================
Or calling it a TCPIP stack might be a stretch.
It is something that under favorable conditions
have some degree of interoperability with a TCPIP
peer.

It is designed to be as small as possible but still capable to
exchange data with a TCP endpoint.
It is designed for use-case where you send a small amount of data,
that fits inside a single TCP segment, to the server and then
wait for and receive a small amount of data, that also must fit inside
a single TCP segment, coming back from the server.

It uses the same static buffer for both sending packets as well as receiving
packets coming back.


SLIP
====
Z80 machines do not come with network interfaces so
this stack is built ontop of SLIP.
SLIP is used to talk between the Z80 host and a
linux host running a special slip endpoint (slip.tap.c)
that bridges the packets between the RS232 port
on the Z80 machine and the outside world.

The implementation of SLIP differs to RFC1055
in that this implementation also ESCapes the 0x00
character, a character which for example the Interface1
on Spectrum appears to have issues with.
Thus this is not compatible with RFC1055 endpoint
but can only be used with slip-tap.c which contais the
same enhancement to the SLIP protocol.

Slip is implemented in slip.c.


-DSLIP_ESC_00
=============
Use this define when compiling for FUSE Spectrum + Interface1.
Both the stack itself as well as slip-tun.c

FUSE Spectrum Interface1 bug
----------------------------
I think there is a bug in the FUSE emulator where it does not handle
the byte 0x00 correctly on rx or tx.
Rx of 0x00 is simply stripped while tx of 0x00 is replaced by the two byte
sequence 0x00 + 0x2a.

When compiling for FUSE Spectrum Interface1 you must define
SLIP_ESC_00 as this will modify the SLIP protocol to also escape the 0x00
characters.
This makes it no longer compatible with standards compliant SLIP implementations
but what can you do.

Use this define when compiling for FUSE Spectrum Interface1   and hook it up
via slip-tun.c as it has the same workaround for this issue.


API
===
Before TCPIP can be used the RS232 SLIP session must be
configured. This is done by calling :

int slip_init(int baud_rate, int parity);
-----------------------------------------

TCPIP
=====
A minimal implementation of "tcpip" is in the files
ip.c
icmp.c
tcp.c

This is a very minimal implementation, designed for small
size and not feature set.
There is no sockets API.
Instead there are four special functions to manage the TCP connection.
The stack only supports a single TCP connection.


int tcp_connect(uint32_t src, uint16_t src_port, uint32_t dst, uint16_t dst_port);
----------------------------------------------------------------------------------

This function is used to establish a TCP connection between src/src_port and
dst/dst_port.
If the attempt fails, for example if it collides with and older session on
the server, it will re-attempt the connection a handful of times
with a random src_port.


int tcp_send(uint8_t *data, int len);
-------------------------------------
Send len amount of data to the server.
Data can be NULL, for example if the application has already written
the PDU directly into the network buffer.

See usmb2.c for an example of writing directly into the tcp buffer in the network
stack and calling tcp_send(NULL, len);
This saves a memcpy() inside tcp_send(),


int tcp_recv(void);
-------------------
This reads and populates the network buffer with the next packet of
TCP payload data.
If rc<0 an error occured.  This is probably not recoverable :-(
If rc==0, no payload was received. Call tcp_recv() to continue to wait.
If rc>0 we got rc bytes of TCP payload from the server.
tcp_buffer() can be called to find the start of the tcp buffer.


uint8_t *tcp_buffer(void);
--------------------------
This function returns the buffer of the tcp payload.


Timings/Timeouts
================
On FUSE Interface1, if there is no data to read then each rs232_get() takes ~12ms.
This can be used as a timeout to break out of the loop in tcp_recv() if there is not
data to receive.
We possibly need to check how long rs232_get() for an idle serial port takes
for all other interfaces as well.
