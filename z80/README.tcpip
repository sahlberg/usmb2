A tiny TCP/IP stack for Z80
===========================
Or calling it a TCPIP stack might be a stretch.
It is something that under favorable conditions
have some degree of interoperability with a TCPIP
peer.

It is designed to be as small as possible but still capable to
exchange data with a TCP endpoint.
It is designed for use-case where you send a small amount of data,
that fits inside a single TCP segment, to the server and then
wait for and receive a small amount of data, that also must fit inside
a single TCP segment, coming back from the server.

What does it support:
* A single tcp connection.

* A single static buffer for both sending packets as well as receiving
packets coming back.

* Retransmitting after ~1 second IF we sent data but did not receive an ACK.

* Detecting and ignoring when the other side retransmits data.
  (Which happens pretty often as we often are too slow to ACK data quickly
   enough causing the server to retransmit.)
   
* A very small footprint.


Files
=====
slip.c slip.h   # Send and receive IP packets over RS232
ip.c ip.h       # Craft IP heaer for sending packets
icmp.c icmp.h   # If you want to send icmp packets, otherwise skip these
tcp.c tcp.h     # "tcp" layer for sending/receiving data on a "tcp socket"


SLIP
====
Z80 machines do not come with network interfaces so
this stack is built ontop of SLIP.
SLIP is used to talk between the Z80 host and a
linux host running a special slip endpoint (slip.tap.c)
that bridges the packets between the RS232 port
on the Z80 machine and the outside world.

The implementation of SLIP differs to RFC1055
in that this implementation also ESCapes the 0x00
character, a character which for example the Interface1
on Spectrum appears to have issues with.
Thus this is not compatible with RFC1055 endpoint
but can only be used with slip-tap.c which contais the
same enhancement to the SLIP protocol.

Slip is implemented in slip.c.


-DSLIP_ESC_00
=============
Use this define when compiling for FUSE Spectrum + Interface1.
Both the stack itself as well as slip-tun.c

FUSE Spectrum Interface1 bug
----------------------------
I think there is a bug in the FUSE emulator where it does not handle
the byte 0x00 correctly on rx or tx.
Rx of 0x00 is simply stripped while tx of 0x00 is replaced by the two byte
sequence 0x00 + 0x2a.

When compiling for FUSE Spectrum Interface1 you must define
SLIP_ESC_00 as this will modify the SLIP protocol to also escape the 0x00
characters.
This makes it no longer compatible with standards compliant SLIP implementations
but what can you do.

Use this define when compiling for FUSE Spectrum Interface1   and hook it up
via slip-tun.c as it has the same workaround for this issue.


API
===
Before TCPIP can be used the RS232 SLIP session must be
configured. This is done by calling :

int slip_init(int baud_rate, int parity);
-----------------------------------------

TCPIP
=====
A minimal implementation of "tcpip" is in the files
ip.c
icmp.c
tcp.c

This is a very minimal implementation, designed for small
size and not feature set.
There is no sockets API.
Instead there are four special functions to manage the TCP connection.
The stack only supports a single TCP connection.


-DRS232_TPS=xyz
---------------
If there is no data to read rs232_get() will eventually timeout.
We need to know how log this timeout is so that we can detect when we need to do a
retransmission or when the application wants to abort the TCP operation.
This define specifies how many timedout calls to rs232_get() per second and this
will be different for every rs232 implementation.

For Spectrum Interface1 this should be set to 80.
I.e. -DRS232_TPS=80

For other serial ports you will need to etermine what this value should be.
(It does not have to be very accurate.)


int tcp_connect(uint32_t src, uint16_t src_port, uint32_t dst, uint16_t dst_port);
----------------------------------------------------------------------------------

This function is used to establish a TCP connection between src/src_port and
dst/dst_port.
If the attempt fails, for example if it collides with and older session on
the server, it will re-attempt the connection a handful of times
with a random src_port.


int tcp_send(uint8_t *data, int len);
-------------------------------------
Send len amount of data to the server and wait for the server to ACK the data.
Will retransmit the data a few times if the data has not been ACKed after ~1s.

Data can be NULL, for example if the application has already written
the PDU directly into the network buffer.

See usmb2.c for an example of writing directly into the tcp buffer in the network
stack and calling tcp_send(NULL, len);
This saves a memcpy() inside tcp_send(),


int tcp_recv(void);
-------------------
This reads and populates the network buffer with the next packet of
TCP payload data.
If no data has arrived after ~1s the function will timeout with -EAGAIN.
rc==-EAGAIN   We timed out waiting for data from the server.
              Not necessarily an error, could just be that there was
	      no data from the server to read and process.
rc<0          Some error occured.  This is probably not recoverable :-(
rc==0         No payload was received. Call tcp_recv() to continue to wait.
rc>0          We got rc bytes of TCP payload from the server.
              tcp_buffer() can be called to find the start of the tcp buffer.


uint8_t *tcp_buffer(void);
--------------------------
This function returns the buffer for the tcp payload.


Timings/Timeouts
================
On FUSE Interface1, if there is no data to read then each rs232_get() takes ~12ms.
This can be used as a timeout to break out of the loop in tcp_recv() if there is not
data to receive.
We possibly need to check how long rs232_get() for an idle serial port takes
for all other interfaces as well.
