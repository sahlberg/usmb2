/* -*-  mode:c; tab-width:8; c-basic-offset:8; indent-tabs-mode:nil;  -*- */
/* SLIP  From RFC1055 */

#include <stdio.h>
#include <rs232.h>

#include "slip.h"

/* SLIP special character codes
 */
#define ZER             0x00
#define END             0xC0    /* indicates end of packet */
#define ESC             0xDB    /* indicates byte stuffing */
#define ESC_END         0xDC    /* ESC ESC_END means END data byte */
#define ESC_ESC         0xDD    /* ESC ESC_ESC means ESC data byte */
#define ESC_ZER         0xDE    /* ESC ESC_ZER means ZER data byte */


int slip_init(int baud_rate, int parity)
{
        if (rs232_init() != RS_ERR_OK) {
                return -1;
        }
        if (rs232_params(baud_rate, parity) != RS_ERR_OK) {
                return -1;
        }

        return 0;
}

void send_packet(uint8_t *p, int len)
{
        /* send an initial END character to flush out any data that may
         * have accumulated in the receiver due to line noise
         */
        rs232_put(END);
        /* for each byte in the packet, send the appropriate character
         * sequence
         */
        while(len--) {
                switch(*p) {
                        /* if it's the same code as an END character, we send a
                         * special two character code so as not to make the
                         * receiver think we sent an END
                         */
                case END:
                        rs232_put(ESC);
                        rs232_put(ESC_END);
                        break;
                        
                        /* if it's the same code as an ESC character,
                         * we send a special two character code so as not
                         * to make the receiver think we sent an ESC
                         */
                case ESC:
                        rs232_put(ESC);
                        rs232_put(ESC_ESC);
                        break;
                        
                        /* otherwise, we just send the character
                         */
#if 1                        
                case ZER:
                        /* Kludge/workaround.  Fuse emulator when application writes 0x00
                         * to the serial port this becomes 0x00 + 0x2a  on the fifo.
                         */
                        rs232_put(ESC);
                        rs232_put(ESC_ZER);
                        break;
#endif                        
                default:
                        rs232_put(*p);
                }
                
                p++;
        }
        
        /* tell the receiver that we're done sending the packet
         */
        rs232_put(END);
}

/* RECV_PACKET: receives a packet into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int recv_packet(uint8_t *p, int len)
{
        uint8_t c = 0;
        int received = 0;

        /* Wait for an END character */
        while (1) {
                rs232_get(&c);
                if (c == END) {
                        break;
                }
        }
        
        /* sit in a loop reading bytes until we put together
         * a whole packet.
         * Make sure not to copy them into the packet if we
         * run out of room.
         */
        
        while(1) {
                /* get a character to process
                 */
                rs232_get(&c);
                /* handle bytestuffing if necessary
                 */
                switch(c) {
                        
                        /* if it's an END character then we're done with
                         * the packet
                         */
                case END:
                        /* a minor optimization: if there is no
                         * data in the packet, ignore it. This is
                         * meant to avoid bothering IP with all
                         * the empty packets generated by the
                         * duplicate END characters which are in
                         * turn sent to try to detect line noise.
                         */
                        if(received) {
                                return received;
                        }
                        break;
                        /* if it's the same code as an ESC character, wait
                         * and get another character and then figure out
                         * what to store in the packet based on that.
                         */
                case ESC:
                        rs232_get(&c);
                        
                        /* if "c" is not one of these two, then we
                         * have a protocol violation.  The best bet
                         * seems to be to leave the byte alone and
                         * just stuff it into the packet
                         */
                        switch(c) {
                        case ESC_ZER:
                                if(received < len) {
                                        p[received++] = ZER;
                                }
                                break;
                        case ESC_END:
                                if(received < len) {
                                        p[received++] = END;
                                }
                                break;
                        case ESC_ESC:
                                if(received < len) {
                                        p[received++] = ESC;
                                }
                                break;
                        }
                        break;
                default:
                        if(received < len) {
                                p[received++] = c;
                        }
                }
        }
}

