USMB2
=====
micro-SMB2   A tiny SMB2 implementation targeting Z80 and other tiny platforms.

USMB2 strives to be as small as possible and to even be viable for 8-bitters.

It is a modular build where the basic minimal configuration is to just being able to access
and read from files as 'Guest' but where additional features can be selectivly enabled.

-DUSMB2_FEATURE_WRITE adds support to open/create files for writing and pwrite() to write to them.

-DUSMB2_FEATURE_OPENDIR adds support to opendir()/readdir() so you can scan directory content.

-DUSMB2_FEATURE_UNICODE adds unicode support for share and file names.

-DUSMB2_FEATURE_NTLM adds NTLMSSP/NTLMv2 user/password authentication. This adds a lot of code and
basically doubles the size of the client.
This feature currently adds 2658bytes of code when compiled for x86_64.



At the time of writing, code size when compiled for for x86_64 is approximately.
Without authentication support.
1318 bytes: basic support  I.e. map a share, open files for reading.
1513 bytes: basic support + file write support.
1785 bytes: basic support + file write support + opendir()/readdir() support.
2367 bytes: basic support + file write support + opendir()/readdir() + unicode support.

USMB2 context is <550 bytes in size.
Each open file handle uses 16 bytes.
Each open directory handle uses 16 + 256 bytes.


Modules
=======

USMB2 is modular where you cna pick what features you want.
By by default there is no authentication and no write support.

Authentication
--------------
To enable NTLMSSP authentication with NTLMv2, compile with
-DUSMB2_FEATURE_NTLM

Write support
-------------
To enable support to open files with O_RDWR an to write to files, compile
with -DUSMB2_FEATURE_WRITE

opendir support
---------------
To enable opendir()/readdir() support, compile with -DUSMB2_FEATURE_OPENDIR.

unicode support
---------------
To enable unicode support, compile with -DUSMB2_FEATURE_UNICODE.
If not enabled all filenames better be 7-bit ASCII.


LIWP
====
The code in usmb2.c uses read()/write() to access the socket. Platforms that use special function
to do this may need changes.
For example PS2 IOP LWIP afaik requires the use of lwip_send()/lwip_recv() instead.

#define write(a,b,c) lwip_send(a,b,c,0)
#define read(a,b,c) lwip_recv(a,b,c,0)


See ps2-ubms2-cat.c for a linux example on how to use to map a share and read a file.



If using it without NTLM support you need to configure the server to allow
Guest access. On samba you would do this something like:

-- smb.conf snippet begin --
[global]
        workgroup = SAMBA
        max protocol = SMB3
        min protocol = CORE
        ntlm auth = yes
        null passwords = yes
        lanman auth = yes
        strict sync = no
        keepalive = 0
        security = user
        passdb backend = tdbsam
        usershare allow guests = yes
        name resolve order = lmhosts bcast host wins
        log level = 0
        guest ok = yes
        guest account = nobody
        map to guest = Bad User

[SNAP-1]
        path = /data/SNAP-1
        available = yes
        read only = no
        browsable = yes
        writable = yes
-- smb.conf snippet end --

