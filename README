USMB2
=====
micro-SMB2   A tiny SMB2 implementation for where size matters.

USMB2 strives to be as small as possible.
The default is no authentication and depending on the server allowing access as a Guest user.
See google for how to enable Guest access for windows file servers or see below for how
to configure samba like that.

Optionally, it can be compiled with NTLMV2 authentication, i.e. normal SMB authentication
by compiling with -DUSMB2_FEATURE_NTLM.
This however adds ~2800bytes of code when compiled for x86_64.

By default it only supprots read-only access to files. Support for usmb2_prwite() and O_RDWR
when opening files can be enabled by compiling with -DUSMB2_FEATURE_WRITE.
This adds about 200 bytes of code size.

Support for opendir/readdir can be enabled with -DUSMB2_FEATURE_OPENDIR.


At the time of writing, code size when compiled for for x86_64 is approximately.
Without authentication support.
1330 bytes: basic support  I.e. map a share, open files for reading and read from them.
1532 bytes: basic support + file write support
1793 bytes: basic support + file write support + opendir()/readdir() support.

USMB2 context is ~550 bytes in size.
Each open file handle uses 16 bytes.
Each open directory handle uses 16 + 256 bytes.


Modules
=======

USMB2 is modular where you cna pick what features you want.
By by default there is no authentication and no write support.

Authentication
--------------
To enable NTLMSSP authentication with NTLMv2, compile with
-DUSMB2_FEATURE_NTLM

Write support
-------------
To enable support to open files with O_RDWR an to write to files, compile
with -DUSMB2_FEATURE_WRITE
This adds about 200 bytes to the code size when compiled for x86_64.

opendir support
---------------
To enable opendir()/readdir() support, compile with -DUSMB2_FEATURE_OPENDIR.
It only supports 7-bit ASCII names and required ~210 bytes of additional code when
compiled to x86_64.
Directory handle is 16 + 256 bytes in size.

LIWP
====
The code in usmb2.c uses read()/write() to access the socket. Platforms that use special function
to do this may need changes.
For example PS2 IOP LWIP afaik requires the use of lwip_send()/lwip_recv() instead.

#define write(a,b,c) lwip_send(a,b,c,0)
#define read(a,b,c) lwip_recv(a,b,c,0)


See ps2-ubms2-cat.c for a linux example on how to use to map a share and read a file.



If using it without NTLM support you need to configure the server to allow
Guest access. On samba you would do this something like:

-- smb.conf snippet begin --
[global]
        workgroup = SAMBA
        max protocol = SMB3
        min protocol = CORE
        ntlm auth = yes
        null passwords = yes
        lanman auth = yes
        strict sync = no
        keepalive = 0
        security = user
        passdb backend = tdbsam
        usershare allow guests = yes
        name resolve order = lmhosts bcast host wins
        log level = 0
        guest ok = yes
        guest account = nobody
        map to guest = Bad User

[SNAP-1]
        path = /data/SNAP-1
        available = yes
        read only = no
        browsable = yes
        writable = yes
-- smb.conf snippet end --

